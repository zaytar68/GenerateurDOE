@using GenerateurDOE.Models
@using GenerateurDOE.Services.Interfaces
@inject ISectionConteneurService sectionConteneurService
@inject ITypeSectionService typeSectionService
@inject ISectionLibreService sectionLibreService
@inject IOperationLockService operationLockService
@inject Radzen.NotificationService NotificationService
@inject Radzen.DialogService DialogService

<div class="section-conteneur-editor">
    @if (isLoading)
    {
        <div class="text-center">
            <div class="spinner-border spinner-border-sm" role="status">
                <span class="visually-hidden">Chargement...</span>
            </div>
        </div>
    }
    else
    {
        <!-- Section pour cr√©er un nouveau conteneur -->
        <div class="card mb-4">
            <div class="card-header">
                <h6 class="mb-0">
                    <span class="oi oi-plus" aria-hidden="true"></span>
                    Ajouter un Conteneur de Sections
                </h6>
            </div>
            <div class="card-body">
                <div class="row">
                    <div class="col-md-6">
                        <label class="form-label">Type de Section</label>
                        <select class="form-select" @bind="selectedTypeSection" @bind:after="OnTypeSelectionChanged">
                            <option value="">-- S√©lectionner un type --</option>
                            @foreach (var type in typesDisponibles)
                            {
                                <option value="@type.Id">@type.Nom</option>
                            }
                        </select>
                    </div>
                    <div class="col-md-4">
                        <label class="form-label">Titre (optionnel)</label>
                        <input type="text" class="form-control" @bind="nouveauTitre" 
                               placeholder="Laisser vide pour utiliser le nom du type" />
                    </div>
                    <div class="col-md-2 d-flex align-items-end">
                        <button class="btn btn-primary w-100" @onclick="CreerNouveauConteneur" 
                                disabled="@(selectedTypeSection == 0 || isCreating)">
                            @if (isCreating)
                            {
                                <span class="spinner-border spinner-border-sm me-2"></span>
                            }
                            Cr√©er
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Liste des conteneurs existants -->
        @if (SectionsConteneurs.Any())
        {
            <div class="row">
                @foreach (var conteneur in SectionsConteneurs.OrderBy(sc => sc.Ordre))
                {
                    <div class="col-12 mb-3">
                        <div class="card">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <div>
                                    <h6 class="mb-0">
                                        <span class="badge bg-primary me-2">@conteneur.TypeSection.Nom</span>
                                        @conteneur.Titre
                                    </h6>
                                    <small class="text-muted">@conteneur.Items.Count section(s)</small>
                                </div>
                                <div class="btn-group">
                                    <button class="btn btn-outline-info btn-sm" 
                                            @onclick="() => EditerConteneur(conteneur)">
                                        <span class="oi oi-cog"></span>
                                    </button>
                                    <button class="btn btn-outline-danger btn-sm" 
                                            @onclick="() => SupprimerConteneur(conteneur)">
                                        <span class="oi oi-trash"></span>
                                    </button>
                                </div>
                            </div>
                            <div class="card-body">
                                @if (!conteneur.Items.Any())
                                {
                                    <div class="text-center text-muted py-3">
                                        <span class="oi oi-document" style="font-size: 2rem; opacity: 0.3;"></span>
                                        <p class="mt-2">Aucune section ajout√©e</p>
                                        <button class="btn btn-outline-primary btn-sm" 
                                                @onclick="() => AjouterSection(conteneur)">
                                            Ajouter la premi√®re section
                                        </button>
                                    </div>
                                }
                                else
                                {
                                    <div class="sections-list">
                                        @foreach (var item in conteneur.Items.OrderBy(i => i.Ordre))
                                        {
                                            var section = item.SectionLibre;
                                            var isFirst = item.Ordre == conteneur.Items.Min(i => i.Ordre);
                                            var isLast = item.Ordre == conteneur.Items.Max(i => i.Ordre);
                                            
                                            <div class="section-item d-flex justify-content-between align-items-center p-2 border rounded mb-2" data-item-id="@item.Id">
                                                <div class="flex-grow-1">
                                                    <div class="d-flex align-items-center">
                                                        <span class="drag-handle me-2" style="cursor: move;" title="Glisser pour r√©organiser">‚ãÆ‚ãÆ</span>
                                                        <div class="flex-grow-1">
                                                            <div class="d-flex justify-content-between align-items-start">
                                                                <div>
                                                                    <strong>@(section.Titre)</strong>
                                                                    <span class="badge bg-secondary ms-2 small">@item.Ordre</span>
                                                                    <br>
                                                                    <small class="text-muted section-preview">
                                                                        @if (!string.IsNullOrWhiteSpace(section.ContenuHtml))
                                                                        {
                                                                            @((MarkupString)TronquerHtml(section.ContenuHtml, 100))
                                                                        }
                                                                    </small>
                                                                </div>
                                                                <div class="d-flex flex-column">
                                                                    <button class="btn btn-outline-secondary btn-sm mb-1" 
                                                                            @onclick="() => DeplacerSectionVersLeHaut(conteneur, item)"
                                                                            disabled="@isFirst" title="D√©placer vers le haut">
                                                                        <span class="oi oi-chevron-top"></span>
                                                                    </button>
                                                                    <button class="btn btn-outline-secondary btn-sm" 
                                                                            @onclick="() => DeplacerSectionVersLeBas(conteneur, item)"
                                                                            disabled="@isLast" title="D√©placer vers le bas">
                                                                        <span class="oi oi-chevron-bottom"></span>
                                                                    </button>
                                                                </div>
                                                            </div>
                                                        </div>
                                                    </div>
                                                </div>
                                                <div class="btn-group ms-2">
                                                    <button class="btn btn-outline-secondary btn-sm" 
                                                            @onclick="() => EditerSection(section)">
                                                        <span class="oi oi-pencil"></span>
                                                    </button>
                                                    <button class="btn btn-outline-danger btn-sm" 
                                                            @onclick="() => RetirerSectionItem(conteneur, item)">
                                                        <span class="oi oi-minus"></span>
                                                    </button>
                                                </div>
                                            </div>
                                        }
                                    </div>
                                    <div class="mt-3">
                                        <button class="btn btn-outline-primary btn-sm" 
                                                @onclick="() => AjouterSection(conteneur)">
                                            <span class="oi oi-plus"></span>
                                            Ajouter une section
                                        </button>
                                    </div>
                                }
                            </div>
                        </div>
                    </div>
                }
            </div>
        }
        else
        {
            <div class="text-center text-muted py-4">
                <span class="oi oi-layers" style="font-size: 3rem; opacity: 0.3;"></span>
                <p class="mt-2">Aucun conteneur de sections cr√©√©</p>
                <p class="small">S√©lectionnez un type de section ci-dessus pour commencer</p>
            </div>
        }
    }
</div>

@code {
    [Parameter] public List<SectionConteneur> SectionsConteneurs { get; set; } = new();
    [Parameter] public int DocumentId { get; set; }
    [Parameter] public EventCallback<List<SectionConteneur>> OnSectionsChanged { get; set; }

    private List<TypeSection> typesSection = new();
    private List<TypeSection> typesDisponibles = new();
    private List<SectionLibre> sectionsLibresDisponibles = new();
    
    private bool isLoading = false;
    private bool isCreating = false;
    private int selectedTypeSection = 0;
    private string nouveauTitre = string.Empty;

    protected override async Task OnInitializedAsync()
    {
        await ChargerDonnees();
    }

    private async Task ChargerDonnees()
    {
        try
        {
            isLoading = true;
            
            // Charger tous les types de sections
            typesSection = (await typeSectionService.GetAllAsync()).ToList();
            
            // Charger les sections libres disponibles
            sectionsLibresDisponibles = (await sectionLibreService.GetAllAsync()).ToList();
            
            // Calculer les types disponibles (ceux qui n'ont pas encore de conteneur)
            MettreAJourTypesDisponibles();
        }
        catch (Exception ex)
        {
            NotificationService.Notify(Radzen.NotificationSeverity.Error, "Erreur", 
                $"Erreur lors du chargement: {ex.Message}");
        }
        finally
        {
            isLoading = false;
        }
    }

    private void MettreAJourTypesDisponibles()
    {
        var typesUtilises = SectionsConteneurs.Select(sc => sc.TypeSectionId).ToList();
        typesDisponibles = typesSection.Where(ts => !typesUtilises.Contains(ts.Id)).ToList();
    }

    private void OnTypeSelectionChanged()
    {
        if (selectedTypeSection > 0)
        {
            var typeSelectionne = typesSection.FirstOrDefault(ts => ts.Id == selectedTypeSection);
            if (typeSelectionne != null && string.IsNullOrWhiteSpace(nouveauTitre))
            {
                nouveauTitre = typeSelectionne.Nom;
            }
        }
    }

    private async Task CreerNouveauConteneur()
    {
        if (selectedTypeSection == 0) return;

        // üîß CORRECTION CONCURRENCE: Protection anti-concurrence UI
        var operationKey = $"create-container-{DocumentId}-{selectedTypeSection}";
        var executed = await operationLockService.ExecuteWithLockAsync(operationKey, async () =>
        {
            try
            {
                isCreating = true;

                var conteneur = await sectionConteneurService.CreateAsync(
                    DocumentId,
                    selectedTypeSection,
                    string.IsNullOrWhiteSpace(nouveauTitre) ? null : nouveauTitre);

                SectionsConteneurs.Add(conteneur);
                MettreAJourTypesDisponibles();

                // Reset du formulaire
                selectedTypeSection = 0;
                nouveauTitre = string.Empty;

                // üîß CORRECTION: InvokeAsync dans la m√™me op√©ration prot√©g√©e
                await OnSectionsChanged.InvokeAsync(SectionsConteneurs);

                NotificationService.Notify(Radzen.NotificationSeverity.Success, "Succ√®s",
                    $"Conteneur '{conteneur.Titre}' cr√©√© avec succ√®s");
            }
            catch (Exception ex)
            {
                NotificationService.Notify(Radzen.NotificationSeverity.Error, "Erreur", ex.Message);
                throw; // Re-throw pour la gestion par OperationLockService
            }
            finally
            {
                isCreating = false;
            }
        });

        if (!executed)
        {
            NotificationService.Notify(Radzen.NotificationSeverity.Warning, "Op√©ration ignor√©e",
                "Une op√©ration similaire est d√©j√† en cours");
        }
    }

    private async Task SupprimerConteneur(SectionConteneur conteneur)
    {
        var result = await DialogService.Confirm(
            $"√ätes-vous s√ªr de vouloir supprimer le conteneur '{conteneur.Titre}' ?",
            "Confirmation de suppression",
            new Radzen.ConfirmOptions { OkButtonText = "Supprimer", CancelButtonText = "Annuler" });

        if (result == true)
        {
            try
            {
                // üîß CORRECTION CONCURRENCE: Protection deletion
                var operationKey = $"delete-container-{conteneur.Id}";
                var executed = await operationLockService.ExecuteWithLockAsync(operationKey, async () =>
                {
                    await sectionConteneurService.DeleteAsync(conteneur.Id);
                    SectionsConteneurs.Remove(conteneur);
                    MettreAJourTypesDisponibles();

                    await OnSectionsChanged.InvokeAsync(SectionsConteneurs);

                    NotificationService.Notify(Radzen.NotificationSeverity.Success, "Succ√®s",
                        "Conteneur supprim√© avec succ√®s");
                });

                if (!executed)
                {
                    NotificationService.Notify(Radzen.NotificationSeverity.Warning, "Op√©ration ignor√©e",
                        "Une op√©ration de suppression est d√©j√† en cours");
                }
            }
            catch (Exception ex)
            {
                NotificationService.Notify(Radzen.NotificationSeverity.Error, "Erreur", ex.Message);
            }
        }
    }

    private void EditerConteneur(SectionConteneur conteneur)
    {
        // TODO: Impl√©menter l'√©dition du conteneur (titre, ordre, etc.)
        NotificationService.Notify(Radzen.NotificationSeverity.Info, "√Ä venir", 
            "√âdition des propri√©t√©s du conteneur en cours de d√©veloppement");
    }

    private async Task AjouterSection(SectionConteneur conteneur)
    {
        try
        {
            var result = await DialogService.OpenAsync<SectionSelectionDialog>("Ajouter des sections",
                new Dictionary<string, object>
                {
                    { "SectionConteneursId", conteneur.Id },
                    { "TypeSectionId", conteneur.TypeSectionId },
                    { "TypeSectionNom", conteneur.TypeSection.Nom }
                },
new Radzen.DialogOptions
                {
                    Width = "800px",
                    Height = "600px",
                    Resizable = true,
                    Draggable = true,
                    CloseDialogOnOverlayClick = false
                });

            if (result != null && result is List<int>)
            {
                var sectionsSelectionneesList = (List<int>)result;
                if (sectionsSelectionneesList.Any())
                {
                    // üîß CORRECTION CONCURRENCE: Protection ajout multiple sections
                    var operationKey = $"add-sections-{conteneur.Id}";
                    var executed = await operationLockService.ExecuteWithLockAsync(operationKey, async () =>
                    {
                        // Ajouter les sections s√©lectionn√©es au conteneur
                        var itemsAjoutes = await sectionConteneurService.AddMultipleSectionsLibresAsync(
                            conteneur.Id, sectionsSelectionneesList);

                        // Recharger le conteneur pour avoir les nouvelles donn√©es
                        var conteneurMisAJour = await sectionConteneurService.GetByIdAsync(conteneur.Id);
                        var index = SectionsConteneurs.FindIndex(sc => sc.Id == conteneur.Id);
                        if (index >= 0)
                        {
                            SectionsConteneurs[index] = conteneurMisAJour;
                        }

                        await OnSectionsChanged.InvokeAsync(SectionsConteneurs);

                        NotificationService.Notify(Radzen.NotificationSeverity.Success, "Succ√®s",
                            $"{itemsAjoutes.Count} section(s) ajout√©e(s) au conteneur");
                    });

                    if (!executed)
                    {
                        NotificationService.Notify(Radzen.NotificationSeverity.Warning, "Op√©ration ignor√©e",
                            "Une op√©ration d'ajout est d√©j√† en cours");
                    }
                }
            }
        }
        catch (Exception ex)
        {
            NotificationService.Notify(Radzen.NotificationSeverity.Error, "Erreur", ex.Message);
        }
    }

    private async Task RetirerSection(SectionConteneur conteneur, SectionLibre section)
    {
        try
        {
            await sectionConteneurService.RemoveSectionLibreAsync(conteneur.Id, section.Id);
            
            await OnSectionsChanged.InvokeAsync(SectionsConteneurs);
            
            NotificationService.Notify(Radzen.NotificationSeverity.Success, "Succ√®s", 
                $"Section '{section.Titre}' retir√©e du conteneur");
        }
        catch (Exception ex)
        {
            NotificationService.Notify(Radzen.NotificationSeverity.Error, "Erreur", ex.Message);
        }
    }

    private void EditerSection(SectionLibre section)
    {
        // Navigation vers la page d'√©dition des sections libres
        // TODO: Impl√©menter selon les besoins
        NotificationService.Notify(Radzen.NotificationSeverity.Info, "√Ä venir", 
            "√âdition directe des sections en cours de d√©veloppement");
    }

    // Nouvelles m√©thodes pour g√©rer les SectionConteneurItem
    private async Task RetirerSectionItem(SectionConteneur conteneur, SectionConteneurItem item)
    {
        var result = await DialogService.Confirm(
            $"√ätes-vous s√ªr de vouloir retirer la section '{item.SectionLibre.Titre}' du conteneur ?",
            "Confirmation de suppression",
            new Radzen.ConfirmOptions { OkButtonText = "Retirer", CancelButtonText = "Annuler" });

        if (result == true)
        {
            try
            {
                // üîß CORRECTION CONCURRENCE: Protection suppression item
                var operationKey = $"remove-item-{item.Id}";
                var executed = await operationLockService.ExecuteWithLockAsync(operationKey, async () =>
                {
                    await sectionConteneurService.RemoveSectionLibreItemAsync(item.Id);

                    // Recharger le conteneur
                    var conteneurMisAJour = await sectionConteneurService.GetByIdAsync(conteneur.Id);
                    var index = SectionsConteneurs.FindIndex(sc => sc.Id == conteneur.Id);
                    if (index >= 0)
                    {
                        SectionsConteneurs[index] = conteneurMisAJour;
                    }

                    await OnSectionsChanged.InvokeAsync(SectionsConteneurs);

                    NotificationService.Notify(Radzen.NotificationSeverity.Success, "Succ√®s",
                        $"Section '{item.SectionLibre.Titre}' retir√©e du conteneur");
                });

                if (!executed)
                {
                    NotificationService.Notify(Radzen.NotificationSeverity.Warning, "Op√©ration ignor√©e",
                        "Une op√©ration est d√©j√† en cours");
                }
            }
            catch (Exception ex)
            {
                NotificationService.Notify(Radzen.NotificationSeverity.Error, "Erreur", ex.Message);
            }
        }
    }

    private async Task DeplacerSectionVersLeHaut(SectionConteneur conteneur, SectionConteneurItem item)
    {
        try
        {
            var items = conteneur.Items.OrderBy(i => i.Ordre).ToList();
            var currentIndex = items.FindIndex(i => i.Id == item.Id);
            
            if (currentIndex > 0)
            {
                // √âchanger avec l'item pr√©c√©dent
                var previousItem = items[currentIndex - 1];
                var tempOrdre = item.Ordre;
                item.Ordre = previousItem.Ordre;
                previousItem.Ordre = tempOrdre;

                // Mettre √† jour l'ordre dans la base de donn√©es
                var itemIds = items.Select(i => i.Id).ToList();
                itemIds.RemoveAt(currentIndex);
                itemIds.Insert(currentIndex - 1, item.Id);
                
                // üîß CORRECTION CONCURRENCE: Protection r√©organisation
                var operationKey = $"reorder-up-{conteneur.Id}-{item.Id}";
                var executed = await operationLockService.ExecuteWithLockAsync(operationKey, async () =>
                {
                    await sectionConteneurService.ReorderItemsAsync(conteneur.Id, itemIds);

                    // Recharger pour avoir les bonnes donn√©es
                    await RechargerConteneur(conteneur);

                    NotificationService.Notify(Radzen.NotificationSeverity.Success, "Succ√®s",
                        "Section d√©plac√©e vers le haut");
                });

                if (!executed)
                {
                    NotificationService.Notify(Radzen.NotificationSeverity.Warning, "Op√©ration ignor√©e",
                        "Une r√©organisation est d√©j√† en cours");
                }
            }
        }
        catch (Exception ex)
        {
            NotificationService.Notify(Radzen.NotificationSeverity.Error, "Erreur", ex.Message);
        }
    }

    private async Task DeplacerSectionVersLeBas(SectionConteneur conteneur, SectionConteneurItem item)
    {
        try
        {
            var items = conteneur.Items.OrderBy(i => i.Ordre).ToList();
            var currentIndex = items.FindIndex(i => i.Id == item.Id);
            
            if (currentIndex < items.Count - 1)
            {
                // √âchanger avec l'item suivant
                var nextItem = items[currentIndex + 1];
                var tempOrdre = item.Ordre;
                item.Ordre = nextItem.Ordre;
                nextItem.Ordre = tempOrdre;

                // Mettre √† jour l'ordre dans la base de donn√©es
                var itemIds = items.Select(i => i.Id).ToList();
                itemIds.RemoveAt(currentIndex);
                itemIds.Insert(currentIndex + 1, item.Id);
                
                // üîß CORRECTION CONCURRENCE: Protection r√©organisation bas
                var operationKey = $"reorder-down-{conteneur.Id}-{item.Id}";
                var executed = await operationLockService.ExecuteWithLockAsync(operationKey, async () =>
                {
                    await sectionConteneurService.ReorderItemsAsync(conteneur.Id, itemIds);

                    // Recharger pour avoir les bonnes donn√©es
                    await RechargerConteneur(conteneur);

                    NotificationService.Notify(Radzen.NotificationSeverity.Success, "Succ√®s",
                        "Section d√©plac√©e vers le bas");
                });

                if (!executed)
                {
                    NotificationService.Notify(Radzen.NotificationSeverity.Warning, "Op√©ration ignor√©e",
                        "Une r√©organisation est d√©j√† en cours");
                }
            }
        }
        catch (Exception ex)
        {
            NotificationService.Notify(Radzen.NotificationSeverity.Error, "Erreur", ex.Message);
        }
    }

    private async Task RechargerConteneur(SectionConteneur conteneur)
    {
        var conteneurMisAJour = await sectionConteneurService.GetByIdAsync(conteneur.Id);
        var index = SectionsConteneurs.FindIndex(sc => sc.Id == conteneur.Id);
        if (index >= 0)
        {
            SectionsConteneurs[index] = conteneurMisAJour;
        }
        await OnSectionsChanged.InvokeAsync(SectionsConteneurs);
        StateHasChanged();
    }

    private string TronquerHtml(string html, int maxLength)
    {
        if (string.IsNullOrWhiteSpace(html))
            return string.Empty;

        if (html.Length <= maxLength)
            return html;

        // Tronquer √† la longueur maximale et ajouter "..."
        var tronque = html.Substring(0, Math.Min(maxLength, html.Length));

        // Si on a coup√© au milieu d'une balise, essayer de fermer proprement
        if (tronque.EndsWith("<") || tronque.Contains("<") && !tronque.Contains(">"))
        {
            var lastOpenTag = tronque.LastIndexOf('<');
            if (lastOpenTag > 0)
            {
                tronque = tronque.Substring(0, lastOpenTag);
            }
        }

        return tronque + "...";
    }
}

<style>
    .section-conteneur-editor {
        min-height: 200px;
    }
    
    .section-item {
        transition: all 0.2s ease;
    }
    
    .section-item:hover {
        background-color: #f8f9fa;
    }
    
    .drag-handle {
        color: #6c757d;
        font-size: 1.2em;
    }
    
    .drag-handle:hover {
        color: #495057;
    }
    
    .sections-list {
        max-height: 400px;
        overflow-y: auto;
    }

    .section-preview {
        max-height: 3em;
        overflow: hidden;
        display: -webkit-box;
        -webkit-line-clamp: 2;
        -webkit-box-orient: vertical;
    }
</style>