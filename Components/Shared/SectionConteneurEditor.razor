@using GenerateurDOE.Models
@using GenerateurDOE.Services.Interfaces
@using System.Linq
@inject ISectionConteneurService sectionConteneurService
@inject ITypeSectionService typeSectionService
@inject ISectionLibreService sectionLibreService
@inject IOperationLockService operationLockService
@inject Radzen.NotificationService NotificationService
@inject Radzen.DialogService DialogService
@inject IJSRuntime JSRuntime
@implements IDisposable

<div class="section-conteneur-editor">
    @if (isLoading)
    {
        <div class="text-center">
            <div class="spinner-border spinner-border-sm" role="status">
                <span class="visually-hidden">Chargement...</span>
            </div>
        </div>
    }
    else
    {
        <!-- Section pour créer un nouveau conteneur -->
        <div class="card mb-4">
            <div class="card-header">
                <h6 class="mb-0">
                    <span class="oi oi-plus" aria-hidden="true"></span>
                    Ajouter un Conteneur de Sections
                </h6>
            </div>
            <div class="card-body">
                <div class="row">
                    <div class="col-md-6">
                        <label class="form-label">Type de Section</label>
                        <select class="form-select" @bind="selectedTypeSection" @bind:after="OnTypeSelectionChanged">
                            <option value="">-- Sélectionner un type --</option>
                            @foreach (var type in typesDisponibles)
                            {
                                <option value="@type.Id">@type.Nom</option>
                            }
                        </select>
                    </div>
                    <div class="col-md-4">
                        <label class="form-label">Titre (optionnel)</label>
                        <input type="text" class="form-control" @bind="nouveauTitre" 
                               placeholder="Laisser vide pour utiliser le nom du type" />
                    </div>
                    <div class="col-md-2 d-flex align-items-end">
                        <button class="btn btn-primary w-100" @onclick="CreerNouveauConteneur" 
                                disabled="@(selectedTypeSection == 0 || isCreating)">
                            @if (isCreating)
                            {
                                <span class="spinner-border spinner-border-sm me-2"></span>
                            }
                            Créer
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Liste des conteneurs existants -->
        @if (SectionsConteneurs.Any())
        {
            <div class="row">
                @foreach (var conteneur in SectionsConteneurs.OrderBy(sc => sc.Ordre))
                {
                    <div class="col-12 mb-3">
                        <div class="card conteneur-card @GetConteneurCssClass(conteneur)"
                             draggable="true"
                             @ondragstart="@(e => OnConteneurDragStart(e, conteneur))"
                             @ondragover:preventDefault="true"
                             @ondragover="@(e => OnConteneurDragOver(e))"
                             @ondrop:preventDefault="true"
                             @ondrop="@(async e => await OnConteneurDrop(e, conteneur))"
                             @ondragenter="@(e => OnConteneurDragEnter(e, conteneur))"
                             @ondragleave="@(e => OnConteneurDragLeave(e, conteneur))"
                             @ondragend="@(e => OnConteneurDragEnd(e))">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <div class="flex-grow-1 d-flex align-items-center">
                                    <span class="conteneur-drag-handle me-2" title="Glisser pour réorganiser les conteneurs">
                                        <span class="oi oi-menu text-muted"></span>
                                    </span>
                                    <div class="flex-grow-1">
                                    @if (conteneurEnCoursEdition == conteneur.Id)
                                    {
                                        <!-- Mode édition inline -->
                                        <div class="d-flex align-items-center mb-2">
                                            <span class="badge bg-primary me-2">@conteneur.TypeSection.Nom</span>
                                            <div class="flex-grow-1 me-2">
                                                <input type="text" class="form-control form-control-sm"
                                                       @bind="titreEnCoursEdition"
                                                       @onkeypress="@((e) => OnTitreKeyPress(e, conteneur))"
                                                       placeholder="Titre du conteneur"
                                                       disabled="@isSavingTitle" />
                                            </div>
                                            <div class="btn-group">
                                                <button class="btn btn-outline-success btn-sm"
                                                        @onclick="() => SauvegarderTitre(conteneur)"
                                                        disabled="@(isSavingTitle || string.IsNullOrWhiteSpace(titreEnCoursEdition))">
                                                    @if (isSavingTitle)
                                                    {
                                                        <span class="spinner-border spinner-border-sm"></span>
                                                    }
                                                    else
                                                    {
                                                        <span class="oi oi-check"></span>
                                                    }
                                                </button>
                                                <button class="btn btn-outline-secondary btn-sm"
                                                        @onclick="AnnulerEditionTitre"
                                                        disabled="@isSavingTitle">
                                                    <span class="oi oi-x"></span>
                                                </button>
                                            </div>
                                        </div>
                                    }
                                    else
                                    {
                                        <!-- Mode affichage normal -->
                                        <h6 class="mb-0">
                                            <span class="badge bg-primary me-2">@conteneur.TypeSection.Nom</span>
                                            @conteneur.Titre
                                        </h6>
                                    }
                                    <small class="text-muted">@conteneur.Items.Count section(s)</small>
                                    </div>
                                </div>
                                <div class="btn-group">
                                    <button class="btn btn-outline-info btn-sm" 
                                            @onclick="() => EditerConteneur(conteneur)">
                                        <span class="oi oi-cog"></span>
                                    </button>
                                    <button class="btn btn-outline-danger btn-sm" 
                                            @onclick="() => SupprimerConteneur(conteneur)">
                                        <span class="oi oi-trash"></span>
                                    </button>
                                </div>
                            </div>
                            <div class="card-body">
                                @if (!conteneur.Items.Any())
                                {
                                    <div class="text-center text-muted py-3">
                                        <span class="oi oi-document" style="font-size: 2rem; opacity: 0.3;"></span>
                                        <p class="mt-2">Aucune section ajoutée</p>
                                        <button class="btn btn-outline-primary btn-sm" 
                                                @onclick="() => AjouterSection(conteneur)">
                                            Ajouter la première section
                                        </button>
                                    </div>
                                }
                                else
                                {
                                    <div class="sections-list" id="conteneur-@conteneur.Id">
                                        @foreach (var item in conteneur.Items?.Where(i => i != null).OrderBy(i => i.Ordre) ?? Enumerable.Empty<SectionConteneurItem>())
                                        {
                                            var section = item.SectionLibre;
                                            if (section == null) continue;

                                            var validItems = conteneur.Items?.Where(i => i != null) ?? Enumerable.Empty<SectionConteneurItem>();
                                            var isFirst = validItems.Any() && item.Ordre == validItems.Min(i => i.Ordre);
                                            var isLast = validItems.Any() && item.Ordre == validItems.Max(i => i.Ordre);
                                            
                                            <div class="section-item d-flex justify-content-between align-items-center p-2 border rounded mb-2" data-item-id="@item.Id">
                                                <div class="flex-grow-1">
                                                    <div class="d-flex align-items-center">
                                                        <span class="drag-handle me-2" title="Glisser pour réorganiser">
                                                            ⋮⋮
                                                        </span>
                                                        <div class="flex-grow-1">
                                                            <div class="d-flex justify-content-between align-items-start">
                                                                <div>
                                                                    <strong>@item.GetTitreEffectif()</strong>
                                                                    <span class="badge bg-secondary ms-2 small">@item.Ordre</span>
                                                                    @if (item.EstPersonnalise)
                                                                    {
                                                                        <span class="badge bg-warning text-dark ms-2 small">
                                                                            <span class="oi oi-pencil"></span> Personnalisé
                                                                        </span>
                                                                    }
                                                                    else
                                                                    {
                                                                        <span class="badge bg-info ms-2 small">
                                                                            <span class="oi oi-document"></span> Défaut
                                                                        </span>
                                                                    }
                                                                    <br>
                                                                    <small class="text-muted section-preview">
                                                                        @if (!string.IsNullOrWhiteSpace(item.GetContenuEffectif()))
                                                                        {
                                                                            @((MarkupString)TronquerHtml(item.GetContenuEffectif(), 100))
                                                                        }
                                                                    </small>
                                                                </div>
                                                                <div class="d-flex flex-column">
                                                                    <button class="btn btn-outline-secondary btn-sm mb-1" 
                                                                            @onclick="() => DeplacerSectionVersLeHaut(conteneur, item)"
                                                                            disabled="@isFirst" title="Déplacer vers le haut">
                                                                        <span class="oi oi-chevron-top"></span>
                                                                    </button>
                                                                    <button class="btn btn-outline-secondary btn-sm" 
                                                                            @onclick="() => DeplacerSectionVersLeBas(conteneur, item)"
                                                                            disabled="@isLast" title="Déplacer vers le bas">
                                                                        <span class="oi oi-chevron-bottom"></span>
                                                                    </button>
                                                                </div>
                                                            </div>
                                                        </div>
                                                    </div>
                                                </div>
                                                <div class="btn-group ms-2">
                                                    <button class="btn btn-outline-primary btn-sm"
                                                            @onclick="() => EditerSection(item)"
                                                            title="Personnaliser pour ce document">
                                                        <span class="oi oi-pencil"></span>
                                                    </button>
                                                    <button class="btn btn-outline-danger btn-sm"
                                                            @onclick="() => RetirerSectionItem(conteneur, item)"
                                                            title="Retirer du document">
                                                        <span class="oi oi-minus"></span>
                                                    </button>
                                                </div>
                                            </div>
                                        }
                                    </div>
                                    <div class="mt-3">
                                        <button class="btn btn-outline-primary btn-sm" 
                                                @onclick="() => AjouterSection(conteneur)">
                                            <span class="oi oi-plus"></span>
                                            Ajouter une section
                                        </button>
                                    </div>
                                }
                            </div>
                        </div>
                    </div>
                }
            </div>
        }
        else
        {
            <div class="text-center text-muted py-4">
                <span class="oi oi-layers" style="font-size: 3rem; opacity: 0.3;"></span>
                <p class="mt-2">Aucun conteneur de sections créé</p>
                <p class="small">Sélectionnez un type de section ci-dessus pour commencer</p>
            </div>
        }
    }
</div>

@code {
    [Parameter] public List<SectionConteneur> SectionsConteneurs { get; set; } = new();
    [Parameter] public int DocumentId { get; set; }
    [Parameter] public EventCallback<List<SectionConteneur>> OnSectionsChanged { get; set; }

    private List<TypeSection> typesSection = new();
    private List<TypeSection> typesDisponibles = new();
    private List<SectionLibre> sectionsLibresDisponibles = new();
    
    private bool isLoading = false;
    private bool isCreating = false;
    private int selectedTypeSection = 0;
    private string nouveauTitre = string.Empty;

    // Variables pour l'édition inline des titres
    private int conteneurEnCoursEdition = 0;
    private string titreEnCoursEdition = string.Empty;
    private bool isSavingTitle = false;

    // Variables pour le drag & drop des sections
    private DotNetObjectReference<SectionConteneurEditor>? dotNetRef;
    private bool isDragDropInitialized = false;

    // Variables pour le drag & drop des conteneurs
    private SectionConteneur? conteneurDragge = null;
    private SectionConteneur? conteneurCible = null;

    protected override async Task OnInitializedAsync()
    {
        await ChargerDonnees();
    }

    /// <summary>
    /// Méthode appelée après le rendu du composant pour initialiser le drag & drop
    /// </summary>
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender || (!isDragDropInitialized && SectionsConteneurs.Any()))
        {
            await InitializeDragDrop();
        }
    }

    private async Task ChargerDonnees()
    {
        try
        {
            isLoading = true;
            
            // Charger tous les types de sections
            typesSection = (await typeSectionService.GetAllAsync()).ToList();
            
            // Charger les sections libres disponibles
            sectionsLibresDisponibles = (await sectionLibreService.GetAllAsync()).ToList();
            
            // Calculer les types disponibles (ceux qui n'ont pas encore de conteneur)
            MettreAJourTypesDisponibles();
        }
        catch (Exception ex)
        {
            NotificationService.Notify(Radzen.NotificationSeverity.Error, "Erreur", 
                $"Erreur lors du chargement: {ex.Message}");
        }
        finally
        {
            isLoading = false;
        }
    }

    private void MettreAJourTypesDisponibles()
    {
        var typesUtilises = SectionsConteneurs.Select(sc => sc.TypeSectionId).ToList();
        typesDisponibles = typesSection.Where(ts => !typesUtilises.Contains(ts.Id)).ToList();
    }

    private void OnTypeSelectionChanged()
    {
        if (selectedTypeSection > 0)
        {
            var typeSelectionne = typesSection.FirstOrDefault(ts => ts.Id == selectedTypeSection);
            if (typeSelectionne != null && string.IsNullOrWhiteSpace(nouveauTitre))
            {
                nouveauTitre = typeSelectionne.Nom;
            }
        }
    }

    private async Task CreerNouveauConteneur()
    {
        if (selectedTypeSection == 0) return;

        // 🔧 CORRECTION CONCURRENCE: Protection anti-concurrence UI
        var operationKey = $"create-container-{DocumentId}-{selectedTypeSection}";
        var executed = await operationLockService.ExecuteWithLockAsync(operationKey, async () =>
        {
            try
            {
                isCreating = true;

                var conteneur = await sectionConteneurService.CreateAsync(
                    DocumentId,
                    selectedTypeSection,
                    string.IsNullOrWhiteSpace(nouveauTitre) ? null : nouveauTitre);

                SectionsConteneurs.Add(conteneur);
                MettreAJourTypesDisponibles();

                // Reset du formulaire
                selectedTypeSection = 0;
                nouveauTitre = string.Empty;

                // 🔧 CORRECTION: InvokeAsync dans la même opération protégée
                await OnSectionsChanged.InvokeAsync(SectionsConteneurs);

                NotificationService.Notify(Radzen.NotificationSeverity.Success, "Succès",
                    $"Conteneur '{conteneur.Titre}' créé avec succès");
            }
            catch (Exception ex)
            {
                NotificationService.Notify(Radzen.NotificationSeverity.Error, "Erreur", ex.Message);
                throw; // Re-throw pour la gestion par OperationLockService
            }
            finally
            {
                isCreating = false;
            }
        });

        if (!executed)
        {
            NotificationService.Notify(Radzen.NotificationSeverity.Warning, "Opération ignorée",
                "Une opération similaire est déjà en cours");
        }
    }

    private async Task SupprimerConteneur(SectionConteneur conteneur)
    {
        var result = await DialogService.Confirm(
            $"Êtes-vous sûr de vouloir supprimer le conteneur '{conteneur.Titre}' ?",
            "Confirmation de suppression",
            new Radzen.ConfirmOptions { OkButtonText = "Supprimer", CancelButtonText = "Annuler" });

        if (result == true)
        {
            try
            {
                // 🔧 CORRECTION CONCURRENCE: Protection deletion
                var operationKey = $"delete-container-{conteneur.Id}";
                var executed = await operationLockService.ExecuteWithLockAsync(operationKey, async () =>
                {
                    await sectionConteneurService.DeleteAsync(conteneur.Id);
                    SectionsConteneurs.Remove(conteneur);
                    MettreAJourTypesDisponibles();

                    await OnSectionsChanged.InvokeAsync(SectionsConteneurs);

                    NotificationService.Notify(Radzen.NotificationSeverity.Success, "Succès",
                        "Conteneur supprimé avec succès");
                });

                if (!executed)
                {
                    NotificationService.Notify(Radzen.NotificationSeverity.Warning, "Opération ignorée",
                        "Une opération de suppression est déjà en cours");
                }
            }
            catch (Exception ex)
            {
                NotificationService.Notify(Radzen.NotificationSeverity.Error, "Erreur", ex.Message);
            }
        }
    }

    private void EditerConteneur(SectionConteneur conteneur)
    {
        // Démarrer l'édition inline du titre
        conteneurEnCoursEdition = conteneur.Id;
        titreEnCoursEdition = conteneur.Titre;
        StateHasChanged();
    }

    private async Task AjouterSection(SectionConteneur conteneur)
    {
        try
        {
            var result = await DialogService.OpenAsync<SectionSelectionDialog>("Ajouter des sections",
                new Dictionary<string, object>
                {
                    { "SectionConteneursId", conteneur.Id },
                    { "TypeSectionId", conteneur.TypeSectionId },
                    { "TypeSectionNom", conteneur.TypeSection.Nom }
                },
new Radzen.DialogOptions
                {
                    Width = "800px",
                    Height = "600px",
                    Resizable = true,
                    Draggable = true,
                    CloseDialogOnOverlayClick = false
                });

            if (result != null && result is List<int>)
            {
                var sectionsSelectionneesList = (List<int>)result;
                if (sectionsSelectionneesList.Any())
                {
                    // 🔧 CORRECTION CONCURRENCE: Protection ajout multiple sections
                    var operationKey = $"add-sections-{conteneur.Id}";
                    var executed = await operationLockService.ExecuteWithLockAsync(operationKey, async () =>
                    {
                        // Ajouter les sections sélectionnées au conteneur
                        var itemsAjoutes = await sectionConteneurService.AddMultipleSectionsLibresAsync(
                            conteneur.Id, sectionsSelectionneesList);

                        // Recharger le conteneur pour avoir les nouvelles données
                        var conteneurMisAJour = await sectionConteneurService.GetByIdAsync(conteneur.Id);
                        var index = SectionsConteneurs.FindIndex(sc => sc.Id == conteneur.Id);
                        if (index >= 0)
                        {
                            SectionsConteneurs[index] = conteneurMisAJour;
                        }

                        await OnSectionsChanged.InvokeAsync(SectionsConteneurs);

                        NotificationService.Notify(Radzen.NotificationSeverity.Success, "Succès",
                            $"{itemsAjoutes.Count} section(s) ajoutée(s) au conteneur");
                    });

                    if (!executed)
                    {
                        NotificationService.Notify(Radzen.NotificationSeverity.Warning, "Opération ignorée",
                            "Une opération d'ajout est déjà en cours");
                    }
                }
            }
        }
        catch (Exception ex)
        {
            NotificationService.Notify(Radzen.NotificationSeverity.Error, "Erreur", ex.Message);
        }
    }

    private async Task RetirerSection(SectionConteneur conteneur, SectionLibre section)
    {
        try
        {
            await sectionConteneurService.RemoveSectionLibreAsync(conteneur.Id, section.Id);
            
            await OnSectionsChanged.InvokeAsync(SectionsConteneurs);
            
            NotificationService.Notify(Radzen.NotificationSeverity.Success, "Succès", 
                $"Section '{section.Titre}' retirée du conteneur");
        }
        catch (Exception ex)
        {
            NotificationService.Notify(Radzen.NotificationSeverity.Error, "Erreur", ex.Message);
        }
    }

    private async Task EditerSection(SectionConteneurItem item)
    {
        try
        {
            var result = await DialogService.OpenAsync<SectionLibreEditDialog>(
                "Personnaliser la Section pour ce Document",
                new Dictionary<string, object>
                {
                    { "ItemId", item.Id }
                },
                new Radzen.DialogOptions
                {
                    Width = "900px",
                    Height = "auto",
                    Resizable = true,
                    Draggable = true,
                    CloseDialogOnOverlayClick = false,
                    ShowClose = true
                }
            );

            if (result != null && result is SectionConteneurItem)
            {
                var updatedItem = (SectionConteneurItem)result;

                // Recharger le conteneur pour afficher les modifications
                var conteneur = SectionsConteneurs.FirstOrDefault(sc => sc.Id == item.SectionConteneursId);
                if (conteneur != null)
                {
                    await RechargerConteneur(conteneur);

                    var message = updatedItem.EstPersonnalise
                        ? "Section personnalisée avec succès !"
                        : "Section réinitialisée au contenu par défaut !";

                    NotificationService.Notify(Radzen.NotificationSeverity.Success, "Succès", message);
                }
            }
        }
        catch (Exception ex)
        {
            NotificationService.Notify(Radzen.NotificationSeverity.Error, "Erreur",
                $"Erreur lors de l'édition : {ex.Message}");
        }
    }

    // Nouvelles méthodes pour gérer les SectionConteneurItem
    private async Task RetirerSectionItem(SectionConteneur conteneur, SectionConteneurItem item)
    {
        var result = await DialogService.Confirm(
            $"Êtes-vous sûr de vouloir retirer la section '{item.SectionLibre.Titre}' du conteneur ?",
            "Confirmation de suppression",
            new Radzen.ConfirmOptions { OkButtonText = "Retirer", CancelButtonText = "Annuler" });

        if (result == true)
        {
            try
            {
                // 🔧 CORRECTION CONCURRENCE: Protection suppression item
                var operationKey = $"remove-item-{item.Id}";
                var executed = await operationLockService.ExecuteWithLockAsync(operationKey, async () =>
                {
                    await sectionConteneurService.RemoveSectionLibreItemAsync(item.Id);

                    // Recharger le conteneur
                    var conteneurMisAJour = await sectionConteneurService.GetByIdAsync(conteneur.Id);
                    var index = SectionsConteneurs.FindIndex(sc => sc.Id == conteneur.Id);
                    if (index >= 0)
                    {
                        SectionsConteneurs[index] = conteneurMisAJour;
                    }

                    await OnSectionsChanged.InvokeAsync(SectionsConteneurs);

                    NotificationService.Notify(Radzen.NotificationSeverity.Success, "Succès",
                        $"Section '{item.SectionLibre.Titre}' retirée du conteneur");
                });

                if (!executed)
                {
                    NotificationService.Notify(Radzen.NotificationSeverity.Warning, "Opération ignorée",
                        "Une opération est déjà en cours");
                }
            }
            catch (Exception ex)
            {
                NotificationService.Notify(Radzen.NotificationSeverity.Error, "Erreur", ex.Message);
            }
        }
    }

    private async Task DeplacerSectionVersLeHaut(SectionConteneur conteneur, SectionConteneurItem item)
    {
        try
        {
            var items = conteneur.Items.OrderBy(i => i.Ordre).ToList();
            var currentIndex = items.FindIndex(i => i.Id == item.Id);
            
            if (currentIndex > 0)
            {
                // Échanger avec l'item précédent
                var previousItem = items[currentIndex - 1];
                var tempOrdre = item.Ordre;
                item.Ordre = previousItem.Ordre;
                previousItem.Ordre = tempOrdre;

                // Mettre à jour l'ordre dans la base de données
                var itemIds = items.Select(i => i.Id).ToList();
                itemIds.RemoveAt(currentIndex);
                itemIds.Insert(currentIndex - 1, item.Id);
                
                // 🔧 CORRECTION CONCURRENCE: Protection réorganisation
                var operationKey = $"reorder-up-{conteneur.Id}-{item.Id}";
                var executed = await operationLockService.ExecuteWithLockAsync(operationKey, async () =>
                {
                    await sectionConteneurService.ReorderItemsAsync(conteneur.Id, itemIds);

                    // Recharger pour avoir les bonnes données
                    await RechargerConteneur(conteneur);

                    NotificationService.Notify(Radzen.NotificationSeverity.Success, "Succès",
                        "Section déplacée vers le haut");
                });

                if (!executed)
                {
                    NotificationService.Notify(Radzen.NotificationSeverity.Warning, "Opération ignorée",
                        "Une réorganisation est déjà en cours");
                }
            }
        }
        catch (Exception ex)
        {
            NotificationService.Notify(Radzen.NotificationSeverity.Error, "Erreur", ex.Message);
        }
    }

    private async Task DeplacerSectionVersLeBas(SectionConteneur conteneur, SectionConteneurItem item)
    {
        try
        {
            var items = conteneur.Items.OrderBy(i => i.Ordre).ToList();
            var currentIndex = items.FindIndex(i => i.Id == item.Id);
            
            if (currentIndex < items.Count - 1)
            {
                // Échanger avec l'item suivant
                var nextItem = items[currentIndex + 1];
                var tempOrdre = item.Ordre;
                item.Ordre = nextItem.Ordre;
                nextItem.Ordre = tempOrdre;

                // Mettre à jour l'ordre dans la base de données
                var itemIds = items.Select(i => i.Id).ToList();
                itemIds.RemoveAt(currentIndex);
                itemIds.Insert(currentIndex + 1, item.Id);
                
                // 🔧 CORRECTION CONCURRENCE: Protection réorganisation bas
                var operationKey = $"reorder-down-{conteneur.Id}-{item.Id}";
                var executed = await operationLockService.ExecuteWithLockAsync(operationKey, async () =>
                {
                    await sectionConteneurService.ReorderItemsAsync(conteneur.Id, itemIds);

                    // Recharger pour avoir les bonnes données
                    await RechargerConteneur(conteneur);

                    NotificationService.Notify(Radzen.NotificationSeverity.Success, "Succès",
                        "Section déplacée vers le bas");
                });

                if (!executed)
                {
                    NotificationService.Notify(Radzen.NotificationSeverity.Warning, "Opération ignorée",
                        "Une réorganisation est déjà en cours");
                }
            }
        }
        catch (Exception ex)
        {
            NotificationService.Notify(Radzen.NotificationSeverity.Error, "Erreur", ex.Message);
        }
    }

    private async Task RechargerConteneur(SectionConteneur conteneur)
    {
        var conteneurMisAJour = await sectionConteneurService.GetByIdAsync(conteneur.Id);
        var index = SectionsConteneurs.FindIndex(sc => sc.Id == conteneur.Id);
        if (index >= 0)
        {
            SectionsConteneurs[index] = conteneurMisAJour;
        }
        await OnSectionsChanged.InvokeAsync(SectionsConteneurs);
        StateHasChanged();
    }

    private string TronquerHtml(string html, int maxLength)
    {
        if (string.IsNullOrWhiteSpace(html))
            return string.Empty;

        if (html.Length <= maxLength)
            return html;

        // Tronquer à la longueur maximale et ajouter "..."
        var tronque = html.Substring(0, Math.Min(maxLength, html.Length));

        // Si on a coupé au milieu d'une balise, essayer de fermer proprement
        if (tronque.EndsWith("<") || tronque.Contains("<") && !tronque.Contains(">"))
        {
            var lastOpenTag = tronque.LastIndexOf('<');
            if (lastOpenTag > 0)
            {
                tronque = tronque.Substring(0, lastOpenTag);
            }
        }

        return tronque + "...";
    }

    #region Drag & Drop Methods

    /// <summary>
    /// Initialise le drag & drop pour tous les conteneurs avec des sections
    /// </summary>
    private async Task InitializeDragDrop()
    {
        try
        {
            // Créer la référence .NET pour les callbacks JavaScript
            dotNetRef = DotNetObjectReference.Create(this);

            // Initialiser le drag & drop pour chaque conteneur ayant des sections
            foreach (var conteneur in SectionsConteneurs.Where(sc => sc.Items.Any()))
            {
                await JSRuntime.InvokeVoidAsync(
                    "sectionDragDrop.initialize",
                    dotNetRef,
                    $"conteneur-{conteneur.Id}");
            }

            isDragDropInitialized = true;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[DEBUG] InitializeDragDrop error: {ex.Message}");
        }
    }

    /// <summary>
    /// Méthode appelée par JavaScript quand l'ordre des sections change
    /// </summary>
    [JSInvokable]
    public async Task OnItemsReorderedJS(string containerId, int[] itemIds)
    {
        try
        {
            // Extraire l'ID du conteneur depuis le string "conteneur-123"
            var id = int.Parse(containerId.Replace("conteneur-", ""));
            var conteneur = SectionsConteneurs.FirstOrDefault(sc => sc.Id == id);

            if (conteneur != null && itemIds?.Length > 0)
            {
                // Utiliser la protection anti-concurrence existante
                var operationKey = $"reorder-drag-{id}";
                var executed = await operationLockService.ExecuteWithLockAsync(operationKey, async () =>
                {
                    // Utiliser la méthode existante pour réorganiser
                    await sectionConteneurService.ReorderItemsAsync(id, itemIds.ToList());

                    // Recharger le conteneur pour avoir les données à jour
                    await RechargerConteneur(conteneur);

                    NotificationService.Notify(Radzen.NotificationSeverity.Success,
                        "Succès", "Ordre des sections mis à jour par glisser-déposer");
                });

                if (!executed)
                {
                    NotificationService.Notify(Radzen.NotificationSeverity.Warning, "Opération ignorée",
                        "Une réorganisation est déjà en cours");
                }
            }
        }
        catch (Exception ex)
        {
            NotificationService.Notify(Radzen.NotificationSeverity.Error, "Erreur",
                $"Erreur lors de la réorganisation : {ex.Message}");
            Console.WriteLine($"[DEBUG] OnItemsReorderedJS error: {ex.Message}");
        }
    }

    // Méthodes pour le drag & drop des conteneurs
    private void OnConteneurDragStart(DragEventArgs e, SectionConteneur conteneur)
    {
        conteneurDragge = conteneur;
        e.DataTransfer.EffectAllowed = "move";
        StateHasChanged();
    }

    private void OnConteneurDragOver(DragEventArgs e)
    {
        // CRITIQUE: Cet événement doit être appelé constamment pour maintenir la zone de drop active
        e.DataTransfer.DropEffect = "move";
    }

    private void OnConteneurDragEnter(DragEventArgs e, SectionConteneur conteneur)
    {
        if (conteneurDragge != null && conteneurDragge.Id != conteneur.Id)
        {
            conteneurCible = conteneur;
            StateHasChanged();
        }
    }

    private void OnConteneurDragLeave(DragEventArgs e, SectionConteneur conteneur)
    {
        if (conteneurCible?.Id == conteneur.Id)
        {
            conteneurCible = null;
            StateHasChanged();
        }
    }

    private async Task OnConteneurDrop(DragEventArgs e, SectionConteneur conteneurCible)
    {
        // Vérifier qu'on a un conteneur en cours de drag
        if (conteneurDragge == null)
        {
            Console.WriteLine("[DEBUG] Aucun conteneur en cours de drag");
            return;
        }

        // Vérifier qu'on ne se déplace pas sur soi-même
        if (conteneurDragge.Id == conteneurCible.Id)
        {
            Console.WriteLine("[DEBUG] Tentative de drop sur soi-même - ignoré");
            return;
        }

        // Sauvegarder les informations avant manipulation pour éviter les NullReference
        var conteneurDraggeId = conteneurDragge.Id;
        var conteneurDraggeTitle = conteneurDragge?.Titre ?? "Conteneur inconnu";
        var targetOrder = conteneurCible?.Ordre ?? 0;

        try
        {
            Console.WriteLine($"[DEBUG] Déplacement conteneur {conteneurDraggeTitle} vers position {targetOrder}");

            var success = await sectionConteneurService.ReorderConteneurAsync(conteneurDraggeId, targetOrder);

            if (success)
            {
                // Recharger tous les conteneurs depuis la base de données
                var sectinosConteneursUpdated = await sectionConteneurService.GetByDocumentIdAsync(DocumentId);
                SectionsConteneurs.Clear();
                SectionsConteneurs.AddRange(sectinosConteneursUpdated);

                // Notifier les changements
                await OnSectionsChanged.InvokeAsync(SectionsConteneurs);
                StateHasChanged();

                NotificationService.Notify(Radzen.NotificationSeverity.Success, "Succès",
                    $"Conteneur '{conteneurDraggeTitle}' déplacé avec succès !");
            }
            else
            {
                NotificationService.Notify(Radzen.NotificationSeverity.Error, "Erreur",
                    "Erreur lors du déplacement du conteneur.");
            }
        }
        catch (Exception ex)
        {
            NotificationService.Notify(Radzen.NotificationSeverity.Error, "Erreur",
                $"Erreur lors du déplacement : {ex.Message}");
            Console.WriteLine($"[DEBUG] Erreur OnConteneurDrop: {ex.Message}");
            Console.WriteLine($"[DEBUG] Stack trace: {ex.StackTrace}");
        }
        finally
        {
            // Réinitialiser l'état du drag & drop
            OnConteneurDragEnd(e);
        }
    }

    private void OnConteneurDragEnd(DragEventArgs e)
    {
        conteneurDragge = null;
        conteneurCible = null;
        StateHasChanged();
    }

    private string GetConteneurCssClass(SectionConteneur conteneur)
    {
        var cssClass = "";

        // Classes pour le drag & drop
        if (conteneurDragge?.Id == conteneur.Id)
        {
            cssClass += "conteneur-dragging ";
        }

        if (conteneurCible?.Id == conteneur.Id)
        {
            cssClass += "conteneur-drop-target ";
        }

        return cssClass.Trim();
    }

    /// <summary>
    /// Nettoie les ressources du drag & drop
    /// </summary>
    public void Dispose()
    {
        try
        {
            if (dotNetRef != null)
            {
                // Détruire toutes les instances de drag & drop
                JSRuntime.InvokeVoidAsync("sectionDragDrop.destroyAll");
                dotNetRef.Dispose();
                dotNetRef = null;
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[DEBUG] Dispose error: {ex.Message}");
        }
    }

    #endregion

    // Méthodes pour l'édition inline des titres
    private async Task SauvegarderTitre(SectionConteneur conteneur)
    {
        if (string.IsNullOrWhiteSpace(titreEnCoursEdition))
        {
            NotificationService.Notify(Radzen.NotificationSeverity.Warning, "Validation",
                "Le titre ne peut pas être vide");
            return;
        }

        try
        {
            isSavingTitle = true;
            StateHasChanged();

            // 🔧 CORRECTION CONCURRENCE: Protection mise à jour titre
            var operationKey = $"update-title-{conteneur.Id}";
            var executed = await operationLockService.ExecuteWithLockAsync(operationKey, async () =>
            {
                // Mettre à jour le titre dans l'objet
                conteneur.Titre = titreEnCoursEdition.Trim();

                // Sauvegarder via le service
                await sectionConteneurService.UpdateAsync(conteneur);

                // Mettre à jour la liste locale
                var index = SectionsConteneurs.FindIndex(sc => sc.Id == conteneur.Id);
                if (index >= 0)
                {
                    SectionsConteneurs[index] = conteneur;
                }

                // Notifier le parent du changement
                await OnSectionsChanged.InvokeAsync(SectionsConteneurs);

                NotificationService.Notify(Radzen.NotificationSeverity.Success, "Succès",
                    $"Titre du conteneur mis à jour : '{conteneur.Titre}'");
            });

            if (!executed)
            {
                NotificationService.Notify(Radzen.NotificationSeverity.Warning, "Opération ignorée",
                    "Une opération de mise à jour est déjà en cours");
                return;
            }

            // Sortir du mode édition
            AnnulerEditionTitre();
        }
        catch (Exception ex)
        {
            NotificationService.Notify(Radzen.NotificationSeverity.Error, "Erreur",
                $"Erreur lors de la mise à jour : {ex.Message}");
        }
        finally
        {
            isSavingTitle = false;
            StateHasChanged();
        }
    }

    private void AnnulerEditionTitre()
    {
        conteneurEnCoursEdition = 0;
        titreEnCoursEdition = string.Empty;
        StateHasChanged();
    }

    private async Task OnTitreKeyPress(Microsoft.AspNetCore.Components.Web.KeyboardEventArgs e, SectionConteneur conteneur)
    {
        if (e.Key == "Enter")
        {
            await SauvegarderTitre(conteneur);
        }
        else if (e.Key == "Escape")
        {
            AnnulerEditionTitre();
        }
    }
}

<style>
    .section-conteneur-editor {
        min-height: 200px;
    }
    
    .section-item {
        transition: all 0.2s ease;
    }
    
    .section-item:hover {
        background-color: #f8f9fa;
    }
    
    .drag-handle {
        cursor: grab;
        user-select: none;
        padding: 4px;
        border-radius: 3px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        transition: background-color 0.2s;
        font-weight: bold;
        font-size: 1.2em;
        line-height: 1;
        color: #6c757d;
    }

    .drag-handle:hover {
        background-color: #f8f9fa;
        color: #495057;
    }

    .drag-handle:active {
        cursor: grabbing;
        background-color: #e9ecef;
    }
    
    .sections-list {
        max-height: 400px;
        overflow-y: auto;
    }

    .section-preview {
        max-height: 3em;
        overflow: hidden;
        display: -webkit-box;
        -webkit-line-clamp: 2;
        -webkit-box-orient: vertical;
    }

    /* Styles pour SortableJS drag & drop */
    .sortable-ghost {
        opacity: 0.4;
        background-color: #f0f0f0;
        border: 2px dashed #007bff;
    }

    .sortable-chosen {
        background-color: #f9f9f9;
        border: 2px solid #007bff;
    }

    .sortable-drag {
        opacity: 0;
    }

    /* Animation de transition après drop */
    .sections-list .section-item {
        transition: all 0.15s ease;
    }

    /* Améliorer l'indicateur visuel pendant le drag */
    .sections-list.sortable-enabled .section-item {
        position: relative;
    }

    /* Styles pour le drag & drop des conteneurs */
    .conteneur-card[draggable="true"] {
        cursor: move;
        transition: all 0.2s ease;
    }

    .conteneur-card[draggable="true"]:hover {
        background-color: #f8f9fa !important;
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }

    .conteneur-drag-handle {
        cursor: grab;
        padding: 4px;
        border-radius: 3px;
        transition: all 0.2s ease;
    }

    .conteneur-drag-handle:hover {
        background-color: #e9ecef;
        color: #495057 !important;
    }

    .conteneur-dragging {
        opacity: 0.6;
        background-color: #fff3cd !important;
        transform: rotate(1deg);
        border: 2px dashed #f0ad4e;
    }

    .conteneur-drop-target {
        background-color: #d1ecf1 !important;
        border: 2px dashed #17a2b8;
        animation: conteneur-pulse 1s infinite;
    }

    @@keyframes conteneur-pulse {
        0% { box-shadow: 0 0 0 0 rgba(23, 162, 184, 0.7); }
        70% { box-shadow: 0 0 0 10px rgba(23, 162, 184, 0); }
        100% { box-shadow: 0 0 0 0 rgba(23, 162, 184, 0); }
    }

    .conteneur-drop-target .card-header {
        background-color: #bee5eb !important;
    }
</style>